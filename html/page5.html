<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="cache-control" content="max-age=86400"/>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bugtrap: Testable code</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "TeX/mhchem.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="bugtrap.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Bugtrap
   </div>
   <div id="projectbrief">How to code with fewer bugs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Testable code </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><blockquote class="doxtable">
<p>The criterion of the scientific status of a theory is its falsifiability, or refutability, or testability. </p><div id="author"> Karl Popper </div> </blockquote>
<h1><a class="anchor" id="OneResponsibility"></a>
One class, one responsibility</h1>
<p>For code to be testable in practice, it has to be designed with testability in mind. For the most fundamental building blocks, like the <a href="classBugTrap_1_1Circle.html"><code>class Circle</code></a>, there are no dependency on other units, and unit testing is relatively straightforward.</p>
<p>Yet, if full test-coverage is required in parameter space, the combinatorical explosion as discussed in <a class="el" href="page4.html#GoodUnitTests">Writing good unit tests</a> must be avoided. The key point is to divide functionality into simple classes and functions with as few parameters as possible. The <em>single responsibility principle</em> or <em>separation of concerns</em> <a class="el" href="citelist.html#CITEREF_Dijkstra:SoC">[5]</a> is a useful guideline in this respect: every class or module should have responsibility over a single part of functionality. As soon as you have to use the word <span class="quote">and</span> when describing the action of a class, the alarm shoud go off. It is a sign of mixing of concerns.</p>
<p>This principle leads to a large number of simple classes, and sometimes people will complain about the number of classes in the code. To this I say, it is better to have a linearly growing number of simple classes than the combinatorical explosion of complexity in a few god classes.</p>
<h1><a class="anchor" id="DependencyInjection"></a>
Inject the dependencies</h1>
<p>For classes representing aggregates of several other classes things become less straightforward. A few steps above the most fundamental building blocks, the number of dependencies grow exponentially. Faced with the need to set up myraids of helper classes and mockups, which have to be changed each time their interfaces change, developers give up on unit testing and decide to rely on system tests, only. This problem can be mitigated by following the principle of <em>dependency injection</em>. Look at the <a href="classBugTrap_1_1MorganPlus8.html"><code>class MorganPlus8</code></a>. It is derived from the general <a href="classBugTrap_1_1ICar.html"><code>class ICar</code></a> interface. Many of the car functionalities needs an engine to be carried out. In software, one could inject the engine depedency through the car constructor, or through a set function, so that the car functionality could be tested with a mockup engine. However, this would require the engine to be created outside the class. In this case one would have to ensure that the engine lives at least as long as the car. Even worse, in many realistic classes there would be a terribly long list of constructor arguments. This would make the code messy and hard to maintain.</p>
<p>The template based solution <a class="el" href="citelist.html#CITEREF_BeautifulInjection">[22]</a> with the <a href="classBugTrap_1_1NeedsEngine.html"><code>NeedsEngine</code></a> template class, solves this problem by leaving the concrete car constructors like the <a href="classBugTrap_1_1MorganPlus8.html"><code>class MorganPlus8</code></a> clean, and still allows dependency injection of the engine into a testable implementation. Hence the engine-dependent functionality can be tested with a mockup engine.</p>
<h1><a class="anchor" id="Polymorphism"></a>
Use polymorphism instead of conditionals</h1>
<p>Whenever the same <em>if condition</em> is repeated in a class, consider splitting the class into smaller and simpler classes with a common abstract base class. Testing of many small classes is easier than testing a few large ones. The reason is that you avoid the dreaded combinatorical explosion.</p>
<p>It also makes the code easier to maintain. Admittedly you get more classes, but adding a new variant derived from the base class will not involve touching existing code or unit tests. In a single class with conditionals you would have to change a number of conditionals and modify existing unit test suite. Thus, the single class solution grows in complexity and for each new variant, there is a risk of introducing new bugs in existing code.</p>
<p>The polymorphism approach satisfies the <em>open/cosed principle</em>.<a class="el" href="citelist.html#CITEREF_OpenClosedPrinciple">[17]</a> Software enteties should be open for extensions, but closed for modifications.</p>
<h1><a class="anchor" id="NoConstructorWork"></a>
Don't let the constructor do work</h1>
<p>Remember that you have to test all functions in your class. Each test should be carried out independently from the others. Hence, you need a fresh instance of the class object set in the required state before carrying out each test. This means that the constructor must be called before each function test in the test suite of the class. The same goes for any other test suite dependent on the class. For large projects, the complete test suite may become very large and time-consuming to run. Especially when run with memory error detectors such as valgrind, the testing becomes slow. Obviously, one does not want complicated constructor work to be carried out over and over again. Hence, do as little work as possible in the constructor, and preferably nothing than assigning dependencies to the fields.</p>
<h1><a class="anchor" id="GlobalStates"></a>
Avoid global states</h1>
<p>Variables with global scope makes software hard to understand. They are like ghosts which can show up anywhere without passing through visible doors or backdoors. In a magic manner, they influence code and may themselves be modified anywhere. Global variables are the exact opposite to the sound advice of minimizing scope of variables.</p>
<p>For the same reason, the use of singletons <a class="el" href="citelist.html#CITEREF_GoF:DesignPatterns">[7]</a> should be avoided except for logging purposes and perhaps holding configuration constants.</p>
<h1><a class="anchor" id="Inheritance"></a>
Don't abuse inheritance</h1>
<p>Use inheritance for related types, where each derived class <em>is a</em> type of base class. The derived class acquires all the properties and behaviours of the parent class. One of the key features of class inheritance is that a pointer to a derived class is type-compatible with a pointer to its base class. Polymorphism is the art of taking advantage of this powerful feature. Virtual functions and inheritance should be used to achieve run-time polymorphism.</p>
<p>For the lazy programmer, and yes, we have to admit it, we are all lazy, implementation inheritance looks like a cheap way of reusing implementation from one class in another. The drawback is that you not only inherits the functionality you need, but the whole interface of the class. Inheritance breaks encapsulation. In other words, a subclass depends on the implementation details of its superclass for its proper function. Hence, this kind of code reuse is hard to maintain. Inheritance also makes testing more difficult, because inherited functions are impossible to mock out.</p>
<p>According to the composite reuse principle (CRP) one should favor delegation over inheritance as a reuse mechanism. The price to pay are simple forwarding methods, but the bonus is that you can control behaviour in unit tests with dependency injection. Inheritance, on the other hand, makes dependency injection impossible. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<div class="center">
<div class="pagination">
  <a href="index.html">Preface</a>
  <a href="page1.html">Punctuation</a>
  <a href="page2.html">Origins</a>
  <a href="page3.html">Documentation</a>
  <a href="page4.html">Bug traps</a>
  <a href="page5.html">Testable</a>
  <a href="page6.html">Process</a>
  <a href="page7.html">Conclusion</a>
  <a href="citelist.html">Bibliography</a>
</div>
</div>
</body>
</html>
